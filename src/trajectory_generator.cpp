#include <iostream>
#include <math.h>

#include "Eigen-3.3/Eigen/Dense"

#include "trajectory_generator.h"
#include "config.h"
#include "utils.h"
#include "spline.h"

using namespace std;

vector<Trajectory> TrajectoryGenerator::GetTrajectories(const Trajectory &start_trajectory, int target_lane, Point cur_location,
                                                        double cur_velocity, int points_num, const Map &map)
{
    //1. Crete connection helper so it would be easier to complete start_trajectory
    auto connection = CreateConnectionHelper(start_trajectory, cur_location, cur_velocity, map);

    //2. Create spline for given lane so the trajectory would be smooth
    //   NOTE!! that spline's frame is rotated so its x axis is aligned with car's direction when it is
    //   in the last point of the start trajectory
    tk::spline spline = CalcSpline(connection, target_lane, map);

    //3. Create list of possible velocities. We use 3 options: maximum break, maximum throttle, same speed
    vector<double> velocities = {connection.ref_velocity - Config::kMaxVelocityDif,
                                 connection.ref_velocity,
                                 connection.ref_velocity + Config::kMaxVelocityDif};

    //4. Create trajectories with all possible velocities
    vector<Trajectory> trajectories;

    for(auto velocity : velocities)
    {
        if(velocity > 0)
        {
            auto trajectory = GetTrajectory(start_trajectory, target_lane, connection, spline, velocity, points_num, map);

            trajectories.push_back(trajectory);
        }
    }


    return trajectories;
}

Trajectory TrajectoryGenerator::GetTrajectory(const Trajectory &start_trajectory, int target_lane, ConnectionHelper &connection_data,
                                              tk::spline &spline, double velocity, int points_num, const Map &map)
{
    // copy start trajectory so it will be the beginning of the new trajectory
    Trajectory trajectory(start_trajectory, target_lane);

    // this is an approximation for points generations

    // first we take some distant point on the trajectory generated by spline
    double x_target = 30;
    double y_target = spline(x_target);

    // next we calculate how many Config::kTimeStep time intervals we need to get to that point with given velocity
    double dist = Utils::CalcDistance(x_target, y_target);
    double N = dist / (velocity * Config::kTimeStep);

    // then we use this number to calculate x difference for each time step
    double x_delta = x_target / N;

    // spline's frame is rotated so its x axis is in the cars direction, we'll have to rotate the result back
    // rotation is done over the last point of ref_trajectory
    auto last_point = connection_data.GetLastPoint();

    // generate new points using spline frame and rotate them back to initial frame
    for(int i = 0; i < points_num; i++)
    {
        double x = x_delta * (i + 1);
        double y = spline(x);

        double x_shift = x * cos(connection_data.ref_angle) - y * sin(connection_data.ref_angle);
        double y_shift = x * sin(connection_data.ref_angle) + y * cos(connection_data.ref_angle);

        x_shift += last_point.x_;
        y_shift += last_point.y_;

        trajectory.AddPoint(Utils::CreatePointByCartesian(x_shift, y_shift, map));
    }

    return trajectory;
}

tk::spline TrajectoryGenerator::CalcSpline(ConnectionHelper &connection, int lane, const Map &map)
{
    tk::spline spline;

    //the beginning of the spline points is ref_trajectory which contains last N points of the previous trajectory
    vector<double> x, y;
    tie(x, y) = connection.ref_trajectory_.ToVectors();

    // next points for the spline are going to be calculated starting from the last point of trajectory
    auto last_point = connection.GetLastPoint();

    // we are going to aim only lane centers
    double center_d = Utils::GetLaneCenterD(lane);

    // this is a magic number. in practice last_point.s_ + 30 gives a point far enough so normal and tangent
    // acceleration are not violated.
    // although theoretically they are violated with angles more than 0.5 so value 30 is not enough,
    // in practice may be because of spline smoothing, or may be because the result accelerations are averaged,
    // it works most of the time. the only case when it did not work that I remember is when because of some
    // significant configuration change fast random lane change occured. But this doesn't happen anymore because of
    // lane change cost.
    double start_s = 30;

    // so we create three points far away
    auto xy0 = Utils::ConvertToCartesian(last_point.s_ + start_s, center_d, map);
    auto xy1 = Utils::ConvertToCartesian(last_point.s_ + start_s + 30, center_d, map);
    auto xy2 = Utils::ConvertToCartesian(last_point.s_ + start_s + 60, center_d, map);

    x.push_back(xy0[0]);
    x.push_back(xy1[0]);
    x.push_back(xy2[0]);

    y.push_back(xy0[1]);
    y.push_back(xy1[1]);
    y.push_back(xy2[1]);

    // no we rotate frame so its center in the last point the start trajectory and x axis is aligned with the car
    // when it is in the last point
    for(int i = 0; i < x.size(); i++)
    {
        double x_shift = x[i] - last_point.x_;
        double y_shift = y[i] - last_point.y_;

        x[i] = x_shift * cos(-connection.ref_angle) - y_shift * sin(-connection.ref_angle);
        y[i] = x_shift * sin(-connection.ref_angle) + y_shift * cos(-connection.ref_angle);
    }

    // create spline
    spline.set_points(x, y);

    return spline;
}

ConnectionHelper TrajectoryGenerator::CreateConnectionHelper(const Trajectory &trajectory, const Point &cur_location,
                                                             double cur_velocity, const Map &map)
{
    ConnectionHelper connection;

    auto trajectory_size = trajectory.GetSize();

    if(trajectory_size > 1)
    {
        // in case we already received points from the simulator
        // we store last n points to create spline

        connection.ref_trajectory_ = trajectory.Subset(trajectory_size - Config::kConnectPointsNum, Config::kConnectPointsNum);

        auto prev_point = trajectory.GetPoint(trajectory_size - 2);
        auto cur_point = trajectory.GetPoint(trajectory_size - 1);

        // and we use last two points to calculate velocity and angle when car is at the end of start trajectory
        connection.ref_angle = Utils::CalcAngle(prev_point, cur_point);
        connection.ref_velocity = Utils::CalcVelocity(prev_point, cur_point);
    }
    else
    {
        // in case we don't have enough existing points we use current car location to calculate the same values

        double prev_point_s = cur_location.s_ - 1;
        double prev_point_d = cur_location.d_;
        auto cartesian = Utils::ConvertToCartesian(prev_point_s, prev_point_d, map);
        Point prev_point(cartesian[0], cartesian[1], prev_point_s, prev_point_d);

        connection.ref_trajectory_.AddPoint(prev_point);
        connection.ref_trajectory_.AddPoint(cur_location);
        connection.ref_velocity = cur_velocity;
        connection.ref_angle = Utils::CalcAngle(prev_point, cur_location);
    }

    return connection;
}

vector<double> TrajectoryGenerator::GetOptimalQuintic(double s_0, double s_1, double s_2, double e_0, double e_1, double e_2, double t)
{
    double a_0 = s_0;
    double a_1 = s_1;
    double a_2 = s_2 / 2;

    double c_0 = a_0 + a_1 * t + a_2 * t * t;
    double c_1 = a_1 + 2 * a_2 * t;
    double c_2 = 2 * a_2;

    Eigen::MatrixXd a(3, 3);
    a << pow(t, 3),     pow(t, 4),      pow(t, 5),
         3 * pow(t, 2), 4 * pow(t, 3),  5 * pow(t, 4),
         6 * t,         12 * pow(t, 2), 20 * pow(t, 3);

    Eigen::VectorXd b(3);
    b << e_0 - c_0, e_1 - c_1, e_2 - c_2;

    Eigen::MatrixXd a_i = a.inverse();
    Eigen::VectorXd x = a.inverse()*b;

    double a_3 = x(0);
    double a_4 = x(1);
    double a_5 = x(2);

    return {a_0, a_1, a_2, a_3, a_4, a_5};
}

tuple<double, double> TrajectoryGenerator::GetQuadraticRoots(double a, double b, double c)
{
    //we don't care about what happens outside [0; t_max] interval, so
    //default roots are negative which means they won't be used
    double x_0 = -1;
    double x_1 = -1;

    double eps = 1e-5;

    if(fabs(a) > numeric_limits<double>::epsilon())
    {
        double d = (b * b) - (4 * a * c);
        if(d >= 0)
        {
            x_0 = (-b + sqrt(d))/ (2 * a);
            x_1 = (-b - sqrt(d))/ (2 * a);
        }
    }
    else if(fabs(b) > numeric_limits<double>::epsilon())
    {
        x_0 = -c / b;
        x_1 = x_0;
    }

    return make_tuple(x_0, x_1);
}